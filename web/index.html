<!DOCTYPE html>
<html>

<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="geochef">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png" />

  <!-- 加载动画 -->
  <style>
    .loader {
      background: #FFFFFF;
      bottom: 0;
      left: 0;
      overflow: hidden;
      position: fixed;
      right: 0;
      top: 0;
      z-index: 99999;
    }

    .loader-inner {
      bottom: 0;
      height: 60px;
      left: 0;
      margin: auto;
      position: absolute;
      right: 0;
      top: 0;
      width: 100px;
    }

    .loader-line-wrap {
      animation:
        spin 2000ms cubic-bezier(.175, .885, .32, 1.275) infinite;
      box-sizing: border-box;
      height: 50px;
      left: 0;
      overflow: hidden;
      position: absolute;
      top: 0;
      transform-origin: 50% 100%;
      width: 100px;
    }

    .loader-line {
      border: 4px solid transparent;
      border-radius: 100%;
      box-sizing: border-box;
      height: 100px;
      left: 0;
      margin: 0 auto;
      position: absolute;
      right: 0;
      top: 0;
      width: 100px;
    }

    .loader-line-wrap:nth-child(1) {
      animation-delay: -50ms;
    }

    .loader-line-wrap:nth-child(2) {
      animation-delay: -100ms;
    }

    .loader-line-wrap:nth-child(3) {
      animation-delay: -150ms;
    }

    .loader-line-wrap:nth-child(4) {
      animation-delay: -200ms;
    }

    .loader-line-wrap:nth-child(5) {
      animation-delay: -250ms;
    }

    .loader-line-wrap:nth-child(1) .loader-line {
      border-color: hsl(0, 80%, 60%);
      height: 90px;
      width: 90px;
      top: 7px;
    }

    .loader-line-wrap:nth-child(2) .loader-line {
      border-color: hsl(60, 80%, 60%);
      height: 76px;
      width: 76px;
      top: 14px;
    }

    .loader-line-wrap:nth-child(3) .loader-line {
      border-color: hsl(120, 80%, 60%);
      height: 62px;
      width: 62px;
      top: 21px;
    }

    .loader-line-wrap:nth-child(4) .loader-line {
      border-color: hsl(180, 80%, 60%);
      height: 48px;
      width: 48px;
      top: 28px;
    }

    .loader-line-wrap:nth-child(5) .loader-line {
      border-color: hsl(240, 80%, 60%);
      height: 34px;
      width: 34px;
      top: 35px;
    }

    @keyframes spin {

      0%,
      15% {
        transform: rotate(0);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>

  <title>GeoChef</title>
  <link rel="manifest" href="manifest.json">
</head>

<body>
  <!-- flutter_bootstrap.js 包含了_flutter.loader.load，不能用于自定义初始屏 -->
  <!-- <script src="flutter_bootstrap.js" async></script> -->
  <div class="loader" id="anim_loading">
    <div class="loader-inner">
      <div class="loader-line-wrap">
        <div class="loader-line"></div>
      </div>
      <div class="loader-line-wrap">
        <div class="loader-line"></div>
      </div>
      <div class="loader-line-wrap">
        <div class="loader-line"></div>
      </div>
      <div class="loader-line-wrap">
        <div class="loader-line"></div>
      </div>
      <div class="loader-line-wrap">
        <div class="loader-line"></div>
      </div>
    </div>
  </div>
</body>

<script>
  // https://docs.flutter.dev/platform-integration/web/initialization
  {{flutter_js}}
  {{flutter_build_config}}

  _flutter.loader.load({
    // 加载动画管理
    onEntrypointLoaded: function (engineInitializer) {
      engineInitializer.initializeEngine({
        useColorEmoji: true,
      }).then(function (appRunner) {
        appRunner.runApp();
        document.getElementById('anim_loading').style.display = 'none';
      });
    }
  });

  // 点击图片放大预览
  function showImageOverlay(id) {
    const el = document.getElementById(id);
    if (!el) return;
    // 创建 overlay 背景
    const overlay = document.createElement('div');
    overlay.className = 'overlay';
    overlay.style.cssText = [
      'position:fixed',
      'inset:0',
      'background:rgba(0,0,0,0.65)',
      'z-index:2147483647',
      'cursor:zoom-out'
    ].join(';');
    // 克隆一个图片用于动画（fixed 定位）
    const clone = document.createElement('img');
    clone.src = el.src;
    clone.style.boxShadow = '0 8px 30px rgba(0,0,0,0.6)';
    clone.style.position = 'fixed';
    clone.style.transition = 'all 300ms cubic-bezier(.2,.8,.2,1)';
    clone.style.willChange = 'transform, left, top, width, height';
    clone.style.cursor = 'zoom-out';
    // 计算原图在视窗的位置与尺寸
    const rect = el.getBoundingClientRect();
    const scrollX = window.scrollX || window.pageXOffset;
    const scrollY = window.scrollY || window.pageYOffset;
    // left/top 使用视口坐标
    clone.style.left = `${rect.left}px`;
    clone.style.top = `${rect.top}px`;
    clone.style.width = `${rect.width}px`;
    clone.style.height = `${rect.height}px`;
    // 为了保留原始位置的占位效果，隐藏原图但保留占位
    const prevVisibility = el.style.visibility;
    el.style.visibility = 'hidden';
    // 把 clone 和 overlay 添加入 DOM
    overlay.appendChild(clone);
    document.body.appendChild(overlay);
    // 禁用页面滚动以更好地呈现 overlay
    const prevBodyOverflow = document.body.style.overflow;
    document.body.style.overflow = 'hidden';
    // 触发到中间放大的目标尺寸：最大 95% 的视窗，同时保持图片纵横比
    function computeTarget() {
      const vpW = window.innerWidth;
      const vpH = window.innerHeight;
      const maxW = vpW * 0.95;
      const maxH = vpH * 0.95;
      // 创建临时图片来获取固有比率
      const img = new Image();
      img.src = clone.src;
      return new Promise(resolve => {
        img.onload = () => {
          const ratio = img.naturalWidth / img.naturalHeight;
          let targetW = img.naturalWidth;
          let targetH = img.naturalHeight;
          // 缩放到 maxW/maxH 中的最大适配
          if (targetW > maxW) {
            targetW = maxW;
            targetH = targetW / ratio;
          }
          if (targetH > maxH) {
            targetH = maxH;
            targetW = targetH * ratio;
          }
          const left = (vpW - targetW) / 2;
          const top = (vpH - targetH) / 2;
          resolve({ left, top, width: targetW, height: targetH });
        };
        if (img.complete) img.onload();// 如果图片已经缓存
      });
    }
    // 开始动画到居中
    let currentTarget = null;
    function applyTarget(t) {
      // 强制重绘以确保 transition 生效
      clone.getBoundingClientRect();
      requestAnimationFrame(() => {
        clone.style.left = `${t.left}px`;
        clone.style.top = `${t.top}px`;
        clone.style.width = `${t.width}px`;
        clone.style.height = `${t.height}px`;
      });
    }
    computeTarget().then((t) => {
      currentTarget = t;
      applyTarget(t);
    });
    // 在窗口尺寸改变时，重新计算目标位置/尺寸并应用（仅在放大状态）
    function onResize() {
      if (!isZoomed) return;
      computeTarget().then((t) => {
        currentTarget = t;
        applyTarget(t);
      });
    }
    window.addEventListener('resize', onResize);

    let isZoomed = true;

    // 关闭（反向动画回到原位，然后清理）
    function close() {
      if (!isZoomed) return;
      isZoomed = false;
      // 动画回原位置/尺寸
      clone.style.left = `${rect.left}px`;
      clone.style.top = `${rect.top}px`;
      clone.style.width = `${rect.width}px`;
      clone.style.height = `${rect.height}px`;
      // 等待 transitionend 清理 DOM
      const onEnd = (e) => {
        // 只处理 clone 的 transitionend
        if (e.target !== clone) return;
        clone.removeEventListener('transitionend', onEnd);
        el.style.visibility = prevVisibility || '';
        document.body.style.overflow = prevBodyOverflow || '';
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        window.removeEventListener('resize', onResize);
        document.removeEventListener('keydown', onKey);
      };
      clone.addEventListener('transitionend', onEnd);
    }

    // 点击 clone 或 overlay 关闭
    overlay.addEventListener('pointerup', (ev) => { close(); });
    function onKey(ev) { if (ev.key === 'Escape') close(); }
    document.addEventListener('keydown', onKey);
  }

  // 后续注册到onload的事件会被立即执行
  window.addEventListener('load', (e) => {
    const oldAdd = window.addEventListener;
    window.addEventListener = function (type, fn, options) {
      if (type === 'load' && typeof fn === 'function') {
        setTimeout(() => {
          fn.call(window, e);
        }, 0);
      } else {
        oldAdd.call(window, type, fn, options);
      }
    };
  });
</script>

</html>